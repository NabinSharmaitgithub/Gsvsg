/**
 * Core Philosophy: This ruleset enforces a security model based on anonymous but authenticated sessions.
 * Each user is identified by a unique session ID (`request.auth.uid`). Access to data, particularly
 * chat rooms and messages, is granted based on direct participation. The system is designed for
 * ephemeral, private communication between two parties.
 *
 * Data Structure: The data is organized into four top-level collections:
 * - /sessions/{sessionId}: Stores a user's own session data.
 * - /chatRooms/{chatRoomId}: Contains metadata for a conversation, linking two session IDs.
 * - /messages/{messageId}: Holds individual messages, secured by sender/receiver IDs.
 * - /inviteLinks/{inviteLinkId}: Manages one-time use links for initiating chats.
 *
 * Key Security Decisions:
 * - Anonymous But Authenticated: All operations require a signed-in session (`request.auth != null`),
 *   even if the user is anonymous. This provides a stable UID for security checks.
 * - Participation-Based Access: A user can only access a chat room or its messages if their session ID
 *   is listed as a participant in the chat room document.
 * - No User Listing: It is not possible to list or query the `/sessions` or `/inviteLinks`
 *   collections to protect user privacy and prevent scraping.
 * - Immutable Relationships: Once created, the participants of a chat room and the sender/receiver
 *   of a message cannot be changed.
 *
 * Denormalization for Authorization:
 * This ruleset relies on denormalization for efficient and secure access control.
 * - The `ChatRoom` document contains `user1Id` and `user2Id` fields. This allows rules to grant access
 *   to the document and its subcollections without needing to query other collections.
 * - The `Message` document contains `senderId` and `receiverId`. This allows rules to secure each message
 *   directly based on the authenticated user's session ID.
 *
 * Structural Segregation: The use of separate top-level collections for different data types
 * (/chatRooms, /messages, etc.) creates a clear security boundary for each, allowing for
 * distinct and easy-to-manage rules without complex conditions.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // -------------------------------------------------------------------------
    // Helper Functions
    // -------------------------------------------------------------------------

    /**
     * Returns true if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the authenticated user's UID matches the provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Returns true if the document exists and the user is the owner.
     * Used for safe update and delete operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Returns true if the user is one of the two participants in a chat room.
     */
    function isChatParticipant(chatRoomData) {
      return isSignedIn() && (request.auth.uid == chatRoomData.user1Id || request.auth.uid == chatRoomData.user2Id);
    }

    /**
     * Validates that the creator of a resource is the currently signed-in user.
     * Used on create operations.
     */
    function isResourceCreator(creatorIdField) {
      return isSignedIn() && request.resource.data[creatorIdField] == request.auth.uid;
    }

    /**
     * Validates that a field is immutable on update.
     */
    function isImmutable(fieldName) {
      return request.resource.data[fieldName] == resource.data[fieldName];
    }


    // -------------------------------------------------------------------------
    // Collection Rules
    // -------------------------------------------------------------------------

    /**
     * @description Controls access to chat room documents.
     * @path /chatRooms/{chatRoomId}
     * @allow (get) A user who is a participant (user1Id or user2Id) can read the chat room.
     * @deny (get) A user who is not a participant cannot read the chat room.
     * @allow (create) A signed-in user can create a chat room if they are one of the participants.
     * @deny (update) Chat rooms are immutable after creation.
     * @principle Enforces access control based on a "Closed Collaborators" model.
     */
    match /chatRooms/{chatRoomId} {
      allow get: if isChatParticipant(resource.data);
      allow list: if isSignedIn(); // Client MUST query where user is a participant.
      allow create: if isChatParticipant(request.resource.data) && request.resource.data.user1Id != request.resource.data.user2Id;
      allow update: if false;
      allow delete: if isChatParticipant(resource.data) && resource != null;
    }

    /**
     * @description Controls access to individual message documents.
     * @path /messages/{messageId}
     * @allow (get) The sender or receiver of a message can read it.
     * @deny (get) A user who is not the sender or receiver cannot read the message.
     * @allow (create) A user can send a message, setting themselves as the senderId.
     * @deny (list) Listing all messages is disabled for performance and security.
     * @principle Enforces document ownership and relational integrity for writes.
     */
    match /messages/{messageId} {
      allow get: if isSignedIn() && (isOwner(resource.data.senderId) || isOwner(resource.data.receiverId));
      allow list: if false;
      allow create: if isResourceCreator('senderId') && request.resource.data.senderId != request.resource.data.receiverId;
      allow update: if isSignedIn() && resource != null && isOwner(resource.data.receiverId) && isImmutable('senderId') && isImmutable('receiverId');
      allow delete: if isExistingOwner(resource.data.senderId);
    }

    /**
     * @description Manages one-time use invite links to start chats.
     * @path /inviteLinks/{inviteLinkId}
     * @allow (get) Any authenticated user can read an invite link if they know its ID.
     * @deny (list) Listing all invite links is forbidden to prevent scraping.
     * @allow (create) A user can create an invite link for a chat, setting themselves as the creator.
     * @allow (update) Any user can mark a link as 'used', but cannot change anything else.
     * @deny (delete) Only the creator can delete their own unused invite link.
     * @principle Enforces document ownership for creation and deletion.
     */
    match /inviteLinks/{inviteLinkId} {
      allow get: if isSignedIn();
      allow list: if false;
      allow create: if isResourceCreator('creatorId') && request.resource.data.used == false;
      allow update: if isSignedIn() && resource != null && resource.data.used == false && request.resource.data.used == true && isImmutable('creatorId') && isImmutable('chatRoomId');
      allow delete: if isExistingOwner(resource.data.creatorId);
    }

    /**
     * @description Secures a user's own session document.
     * @path /sessions/{sessionId}
     * @allow (read, write) A user can only access their own session document.
     * @deny (read, write) A user cannot access another user's session document.
     * @deny (list) Listing sessions is forbidden to protect user privacy.
     * @principle Restricts access to a user's own data tree (Ownership model).
     */
    match /sessions/{sessionId} {
      allow get: if isOwner(sessionId);
      allow list: if false;
      allow create: if isOwner(sessionId) && request.resource.data.id == sessionId;
      allow update: if isExistingOwner(sessionId) && isImmutable('id');
      allow delete: if isExistingOwner(sessionId);
    }
  }
}