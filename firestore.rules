/**
 * Core Philosophy: This ruleset secures a real-time anonymous chat application.
 * The security model is based on session-level identity, where each authenticated
 * user has a unique session ID (`request.auth.uid`) that acts as their user ID.
 * Access to chat rooms and messages is granted based on a "closed collaborators"
 * pattern, where only the two designated participants in a chat room can read or
 * write data within it.
 *
 * Data Structure: The data is organized into four top-level collections:
 * - /sessions/{sessionId}: Stores a user's anonymous session data. Access is
 *   strictly limited to the session owner.
 * - /inviteLinks/{inviteLinkId}: Publicly readable links created by users to
 *   initiate new chats. Only the creator can manage their own links.
 * - /chatRooms/{chatRoomId}: Contains metadata for a chat, including the IDs of
 *   the two participants. This document is the source of truth for chat membership.
 * - /messages/{messageId}: Contains all individual chat messages. Access is
 *   granted by checking the parent chat room's participant list.
 *
 * Key Security Decisions:
 * - Session-Based Identity: `request.auth.uid` is treated as the user's unique
 *   and private session identifier.
 * - Strict Chat Membership: All access to `/chatRooms` and `/messages` requires
 *   the user to be one of the two participants defined in the chat room document.
 * - No Public Listing: To prevent data leakage, listing all chat rooms or all
 *   messages is disabled. Client applications must retrieve chat rooms by known
 *   IDs or query for the ones they are a member of.
 * - Ownership for Invites: Invite links can only be created and deleted by their
 *   original creator.
 *
 * Denormalization for Authorization:
 * - The `/chatRooms/{chatRoomId}` document holds `user1Id` and `user2Id`. This
 *   is the authoritative source for membership checks.
 * - The `/messages/{messageId}` documents are expected to contain a `chatRoomId`
 *   field. This denormalized pointer is essential for rules to link a message
 *   back to its chat room to verify if the requesting user is a participant.
 *   This is more performant and secure than trying to infer relationships.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Verifies that a user is signed in.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Verifies that the currently signed-in user's ID matches the provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    /**
     * Verifies that the document being operated on already exists.
     * Crucial for secure update and delete operations.
     */
    function isExistingDoc() {
        return resource != null;
    }

    /**
     * Verifies that a document exists and the requesting user is its owner.
     * Used for secure update and delete operations on user-owned documents.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && isExistingDoc();
    }

    /**
     * Checks if the requesting user is one of the two participants in a given chat room.
     * This requires a 'get' call to the chat room document, making it suitable for
     * securing individual document reads and writes.
     */
    function isChatParticipant(chatRoomId) {
      let chatRoom = get(/databases/$(database)/documents/chatRooms/$(chatRoomId)).data;
      return isSignedIn() && (chatRoom.user1Id == request.auth.uid || chatRoom.user2Id == request.auth.uid);
    }
    
    // ------------------------------------------------------------------------
    // Collection Rules
    // ------------------------------------------------------------------------

    /**
     * @description Secures a user's anonymous session document.
     * @path /sessions/{sessionId}
     * @allow (create) A user creates their own session document: `db.collection('sessions').doc('user_abc').set({ id: 'user_abc', ... })` if auth.uid is 'user_abc'.
     * @deny (get) A user tries to read another user's session document: `db.collection('sessions').doc('user_xyz').get()` if auth.uid is 'user_abc'.
     * @principle Restricts access to a user's own data tree.
     */
    match /sessions/{sessionId} {
      allow get: if isOwner(sessionId);
      allow list: if isOwner(sessionId);
      allow create: if isOwner(sessionId) && request.resource.data.id == sessionId;
      allow update: if isExistingOwner(sessionId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(sessionId);
    }

    /**
     * @description Secures chat room documents, which define chat participants.
     * @path /chatRooms/{chatRoomId}
     * @allow (get) A user who is a participant reads a chat room: `db.collection('chatRooms').doc('chat_123').get()` if auth.uid is a participant in chat_123.
     * @deny (list) Any user tries to list all chat rooms: `db.collection('chatRooms').get()`.
     * @deny (update) A participant tries to change the members of the chat room.
     * @principle Enforces closed-collaborator access based on participant IDs.
     */
    match /chatRooms/{chatRoomId} {
      allow get: if isSignedIn() && (resource.data.user1Id == request.auth.uid || resource.data.user2Id == request.auth.uid);
      allow list: if false; // Denied for security. Clients must query for chats where they are a member.
      allow create: if isSignedIn() && (request.resource.data.user1Id == request.auth.uid || request.resource.data.user2Id == request.auth.uid);
      allow update: if false; // Chat room participants are immutable.
      allow delete: if isExistingDoc() && isSignedIn() && (resource.data.user1Id == request.auth.uid || resource.data.user2Id == request.auth.uid);
    }

    /**
     * @description Secures individual chat messages. Access is derived from membership in the associated chat room.
     * @path /messages/{messageId}
     * @allow (create) A user sends a message to a chat they are part of: `db.collection('messages').add({ senderId: 'user_abc', chatRoomId: 'chat_123', ... })` if auth.uid is 'user_abc' and a member of chat_123.
     * @deny (list) A user tries to list all messages, even with a filter: `db.collection('messages').where('chatRoomId', '==', 'chat_123').get()`.
     * @deny (get) A user tries to read a message from a chat they are not in.
     * @principle Relational security; access is granted based on a related document (the ChatRoom).
     */
    match /messages/{messageId} {
      // NOTE: These rules assume that every message document contains a 'chatRoomId' field that
      // correctly points to its parent chat room. This field is essential for security.
      allow get: if isChatParticipant(resource.data.chatRoomId);
      // CRITICAL: Listing a top-level collection based on checks against a related document is not
      // secure or possible in Firestore rules. The rule cannot access the `where` clause of the query.
      // The recommended secure pattern is to nest messages within a chatRoom subcollection.
      // e.g., /chatRooms/{chatRoomId}/messages/{messageId}
      allow list: if false;
      allow create: if isChatParticipant(request.resource.data.chatRoomId) && request.resource.data.senderId == request.auth.uid;
      allow update: if false; // Messages are immutable for simplicity and security.
      allow delete: if isExistingOwner(resource.data.senderId) && isChatParticipant(resource.data.chatRoomId);
    }

    /**
     * @description Secures invite links for starting new chats.
     * @path /inviteLinks/{inviteLinkId}
     * @allow (create) A signed-in user creates an invite link for a chat: `db.collection('inviteLinks').add({ creatorId: 'user_abc', ... })` if auth.uid is 'user_abc'.
     * @deny (delete) A user tries to delete an invite link they did not create.
     * @principle Enforces document ownership for writes, while allowing reads for any signed-in user.
     */
    match /inviteLinks/{inviteLinkId} {
      allow get, list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.creatorId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.creatorId) && request.resource.data.creatorId == resource.data.creatorId && request.resource.data.chatRoomId == resource.data.chatRoomId;
      allow delete: if isExistingOwner(resource.data.creatorId);
    }
  }
}